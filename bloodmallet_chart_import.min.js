"use strict";

function bloodmallet_chart_import() {
  var e = ["#7cb5ec", "#d9d9df", "#90ed7d", "#f7a35c", "#8085e9", "#f15c80", "#e4d354", "#2b908f", "#f45b5b", "#91e8e1"],
      t = "#343a40",
      o = "#f8f9fa",
      r = "#828282",
      i = "1.1rem",
      l = !1,
      s = "https://bloodmallet.com/json/";
  var a = {};

  function n(e) {
    l && console.log("load_data");
    var t = e.data_type,
        o = e.fight_style,
        r = e.wow_class,
        i = e.wow_spec;

    try {
      if (a[t][o][r][i]) return;
    } catch (g) {
      l && console.log("Data needs to be loaded.");
    }

    var n = t;
    n.indexOf("azerite") > -1 && (n = "azerite_traits");
    var d = r;
    d += "_" + i, t.indexOf("azerite_items") > -1 && (d += t.replace("azerite_items", "")), d += "_" + o, d += ".json", l && console.log("Fetching data from: " + s + n + "/" + d);
    var c = new XMLHttpRequest();
    c.open("GET", s + n + "/" + d + "?" + new Date().getTime(), !0), c.onload = function (e) {
      if (4 === c.readyState) if (200 === c.status) {
        var _e = JSON.parse(c.responseText);

        a[t] || (a[t] = {}), a[t][o] || (a[t][o] = {}), a[t][o][r] || (a[t][o][r] = {}), a[t][o][r][i] = _e, l && (console.log(_e), console.log("Load and save finished."));
      } else console.error(c.statusText);
    };
    var g = !1;
    return c.onerror = function (e) {
      console.error("Fetching data from bloodmallet.com encountered an error, ", e), g = !0;
    }, c.send(null), g;
  }

  function d(e, t, o, r) {
    l && console.log("update_charts");
    var i = e.data_type,
        s = e.fight_style,
        n = e.wow_class,
        g = e.wow_spec,
        _ = e.data_entries,
        p = e.chart_engine;

    try {
      var h = a[i][s][n][g];
    } catch (l) {
      return console.warn("Data for ", i, s, n, g, " wasn't loaded yet. Either chart setup is wrong, connection to bloodmallet.com is slow or failed."), void (r < 10 && setTimeout(d, 100, e, t, o, r + 1));
    }

    var u = h;
    var m, f;
    if (i.indexOf("azerite_traits") > -1) {
      if ("azerite_traits_stacking" === i) "all" === e.azerite_tier ? m = u.sorted_data_keys_2.slice(0, u.sorted_data_keys_2.length) : "1" === e.azerite_tier || "3" === e.azerite_tier ? m = u.sorted_azerite_tier_3_trait_stacking.slice(0, u.sorted_azerite_tier_3_trait_stacking.length) : "2" === e.azerite_tier && (m = u.sorted_azerite_tier_2_trait_stacking.slice(0, u.sorted_azerite_tier_2_trait_stacking.length)), f = u.data.baseline[u.simulated_steps[0]];else {
        if ("azerite_traits_itemlevel" !== i) return void console.log("Chart found, but unknown data-type detected.");
        "all" === e.azerite_tier ? m = u.sorted_data_keys.slice(0, u.sorted_data_keys.length) : "1" === e.azerite_tier || "3" === e.azerite_tier ? m = u.sorted_azerite_tier_3_itemlevel.slice(0, u.sorted_azerite_tier_3_itemlevel.length) : "2" === e.azerite_tier && (m = u.sorted_azerite_tier_2_itemlevel.slice(0, u.sorted_azerite_tier_2_itemlevel.length)), f = u.data.baseline[u.simulated_steps[u.simulated_steps.length - 1]];
      }
    } else "corruptions" === i && "dps/rating" === e.corruption_representation ? (m = u.sorted_data_keys_2.slice(0, u.sorted_data_keys_2.length), f = u.data.baseline[1]) : (m = u.sorted_data_keys.slice(0, u.sorted_data_keys.length), f = "races" === i ? 0 : "essence_combinations" === i ? u.data.baseline : u.data.baseline[u.simulated_steps[u.simulated_steps.length - 1]]);
    l && (console.log(m), console.log("Baseline dps: " + f));
    var y = [];

    if ("azerite_traits_stacking" === i) {
      var _e2 = u.simulated_steps[0].replace("1_", "");

      y.push("3_" + _e2), y.push("2_" + _e2), y.push("1_" + _e2);
    } else y = u.simulated_steps;

    if (l && console.log("simulated_steps: " + y), "essences" === i) {
      purge_list = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = m[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _t = _step.value;
          e.filters.hasOwnProperty("essence_types") && (e.filters.essence_types.indexOf("minor") > -1 && _t.indexOf(" minor") > -1 ? purge_list.push(_t) : e.filters.essence_types.indexOf("combined") > -1 && -1 === _t.indexOf(" minor") && purge_list.push(_t));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = purge_list[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _e3 = _step2.value;
          m.splice(m.indexOf(_e3), 1);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    for (m = m.slice(0, _), o.setTitle({
      text: u.title
    }, {
      text: u.subtitle
    }, !1); o.series[0];) {
      o.series[0].remove(!1);
    }

    var b = [];

    for (var _t2 = 0; _t2 < m.length; _t2++) {
      var _o = m[_t2];
      b.push(c(e, _o, u));
    }

    if (l && console.log(b), "highcharts" == p ? o.update({
      xAxis: {
        categories: b
      }
    }, !1) : "highcharts_old" == p && o.xAxis[0].setCategories(b, !1), !y || "corruptions" === i && "dps/rating" === e.corruption_representation) {
      w = [];

      for (var _t4 = 0; _t4 < m.length; _t4++) {
        var _o2 = m[_t4],
            _r = 0;

        if ("corruptions" === i && "dps/rating" === e.corruption_representation) {
          var _e4 = _o2.slice(0, _o2.length - 2),
              _t5 = _o2.slice(_o2.length - 1, _o2.length);

          _r = (u.data[_e4][_t5] - f) / u.corruption_rating[_e4][_t5];
        } else _r = u.data[_o2];

        w.push(_r);
      }

      var _t3 = "";
      "races" === i && (_t3 = "Race"), o.addSeries({
        data: w,
        name: _t3,
        showInLegend: !0
      }, !1);
    } else for (var _e5 = 0; _e5 < y.length; _e5++) {
      var _t6 = y[_e5];
      var w = [];

      for (var _o3 = 0; _o3 < m.length; _o3++) {
        _t6 = y[_e5];

        var _r3 = y.slice(),
            _l = m[_o3],
            _s = u.data[_l];

        if (f = u.data.baseline[u.simulated_steps[u.simulated_steps.length - 1]], "azerite_traits_stacking" === i && (f = u.data.baseline[u.simulated_steps[0]]), "azerite_traits_stacking" === i && void 0 === _s[_t6]) {
          var _e6 = u.simulated_steps,
              _o4 = void 0;

          for (var _t7 = 0; _t7 < _e6.length; _t7++) {
            var _r4 = _e6[_t7];
            !_o4 && u.data[_l][_r4] && (_o4 = _r4);
          }

          _o4 = _o4.replace("1_", ""), _r3 = [];
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = y[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _e7 = _step3.value;

              _r3.push(_e7.split("_")[0] + "_" + _o4);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          f = u.data.baseline["1_" + _o4], _t6 = _t6.split("_")[0] + "_" + _o4;
        }

        Number(_s[_t6]) > 0 ? _e5 == y.length - 1 ? _t6 in _s ? w.push(_s[_t6] - f) : w.push(0) : 0 !== _s[_r3[String(Number(_e5) + 1)]] && _r3[String(Number(_e5) + 1)] in _s ? w.push(_s[_t6] - _s[_r3[String(Number(_e5) + 1)]]) : w.push(_s[_t6] - f) : _t6 in _s ? w.push(_s[_t6]) : w.push(0);
      }

      var _r2 = _t6;
      ["azerite_items_chest", "azerite_items_head", "azerite_items_shoulders", "azerite_traits_itemlevel"].indexOf(i) > -1 ? _r2 = _t6.split("_")[1] : "azerite_traits_stacking" === i && (_r2 = _t6.split("_")[0]), o.addSeries({
        data: w,
        name: _r2,
        showInLegend: !0
      }, !1);
    }

    "trinkets" == i || "azerite_items_chest" == i || "azerite_items_head" == i || "azerite_items_shoulders" == i || "azerite_traits_itemlevel" == i ? o.legend.title.attr({
      text: "Itemlevel"
    }) : "races" === i ? o.legend.title.attr({
      text: ""
    }) : "azerite_traits_stacking" === i ? o.legend.title.attr({
      text: "Trait count"
    }) : "essences" === i || "corruptions" === i && "dps" === e.corruption_representation ? o.legend.title.attr({
      text: "Rank"
    }) : o.legend.title.attr({
      text: ""
    }), "corruptions" === i && "dps/rating" === e.corruption_representation && (o.yAxis[1].setTitle({
      text: "Δ Damage per second / corruption rating"
    }), o.yAxis[0].setTitle({
      text: "Δ Damage per second / corruption rating"
    })), t.style.height = 200 + 30 * m.length + "px", "highcharts" == p && o.setSize(t.style.width, t.style.height), o.redraw(), "highcharts_old" == p && o.reflow(), "wowdb" == e.tooltip_engine && setTimeout(function () {
      !function (e) {
        l && console.log("readd_wowdb_tooltips");

        try {
          CurseTips["wowdb-tooltip"].watchElements(document.getElementById(e).getElementsByTagName("a"));
        } catch (e) {
          console.log("Setting wowdb (CurseTips) tooltips failed. Error: ", e);
        }
      }(t.id);
    }, 1);
  }

  function c(e, t, o) {
    l && (console.log("get_category_name"), console.log(t), console.log(o));
    var r = {
      cn: "cn_CN",
      en: "en_US",
      de: "de_DE",
      es: "es_ES",
      fr: "fr_FR",
      it: "it_IT",
      ko: "ko_KR",
      pt: "pt_BR",
      ru: "ru_RU"
    };
    if ("wowhead" !== e.tooltip_engine && "wowdb" !== e.tooltip_engine) try {
      return o.languages[t][r[e.language]];
    } catch (e) {
      return t;
    }
    if ("races" === e.data_type) try {
      return o.languages[t][r[e.language]];
    } catch (e) {
      return t;
    }

    if ("wowhead" === e.tooltip_engine) {
      var _i = document.createElement("a");

      if (_i.href = "https://" + ("en" === e.language ? "www" : e.language) + ".wowhead.com/", o.hasOwnProperty("power_ids") && (o.power_ids.hasOwnProperty(t) || o.power_ids.hasOwnProperty(t.split(" +")[0]))) o.power_ids.hasOwnProperty(t) ? _i.href += "azerite-essence-power/" + o.power_ids[t] : o.power_ids.hasOwnProperty(t.split(" +")[0]) && (_i.href += "azerite-essence-power/" + o.power_ids[t.split(" +")[0]]);else if (o.hasOwnProperty("item_ids") && o.item_ids.hasOwnProperty(t)) {
        if (_i.href += "item=" + o.item_ids[t] + "/" + g(t), o.hasOwnProperty("class_id") && o.hasOwnProperty("used_azerite_traits_per_item")) {
          _i.href += "?azerite-powers=" + o.class_id;

          for (var _e9 = 0; _e9 < o.used_azerite_traits_per_item[t].length; _e9++) {
            var _r5 = o.used_azerite_traits_per_item[t][_e9];
            _i.href += ":" + _r5.id;
          }
        }

        var _e8 = o.simulated_steps[o.simulated_steps.length - 1];
        "string" == typeof _e8 && _e8.indexOf("_") > -1 && (_e8 = _e8.split("_")[1]), _i.href += "&ilvl=" + _e8;
      } else if (o.hasOwnProperty("spell_ids") && (o.spell_ids.hasOwnProperty(t) || o.spell_ids.hasOwnProperty(t.slice(0, t.length - 2)))) if ("corruptions" === e.data_type && "dps/rating" === e.corruption_representation) {
        var _e10 = t.slice(0, t.length - 2),
            _r6 = t.slice(t.length - 1, t.length);

        _i.href += "spell=" + o.spell_ids[_e10][_r6] + "/" + g(t);
      } else "corruptions" === e.data_type && "dps" === e.corruption_representation ? _i.href += "spell=" + o.spell_ids[t][1] + "/" + g(t) : _i.href += "spell=" + o.spell_ids[t] + "/" + g(t);

      try {
        _i.appendChild(document.createTextNode(o.languages[t][r[e.language]]));
      } catch (e) {
        _i.appendChild(document.createTextNode(t)), console.log("Bloodmallet charts: Translation for " + t + " wasn't found. Please help improving the reasource at bloodmallet.com.");
      }

      return _i.outerHTML;
    }

    if ("wowdb" == e.tooltip_engine) {
      var _i2 = document.createElement("a");

      _i2.href = "http://www.wowdb.com/";

      try {
        _i2.href += "items/" + o.item_ids[t];
      } catch (e) {
        l && (console.log(e), console.log("We're probably looking at a spell."));
      }

      if (_i2.href.indexOf("items") > -1) {
        var _e11 = o.simulated_steps[o.simulated_steps.length - 1];

        if ("string" == typeof _e11 && _e11.indexOf("_") > -1 && (_e11 = _e11.split("_")[1]), _i2.href += "?itemLevel=" + _e11, o.hasOwnProperty("class_id") && o.hasOwnProperty("used_azerite_traits_per_item")) {
          _i2.href += "&azerite=", _i2.href += o.class_id + ":0";

          for (var _e12 = 0; _e12 < o.used_azerite_traits_per_item[t].length; _e12++) {
            var _r7 = o.used_azerite_traits_per_item[t][_e12];
            _i2.href += ":" + _r7.id;
          }
        }
      } else try {
        if ("essence_combinations" === e.data_type) _i2.href += "spells/" + o.spell_ids[t.split(" +")[0]];else if ("corruptions" === e.data_type && "dps/rating" === e.corruption_representation) {
          var _e13 = t.slice(0, t.length - 2),
              _r8 = t.slice(t.length - 1, t.length);

          _i2.href += "spell/" + o.spell_ids[_e13][_r8];
        } else "corruptions" === e.data_type && "dps" === e.corruption_representation ? _i2.href += "spell/" + o.spell_ids[t][1] : _i2.href += "spells/" + o.spell_ids[t];
      } catch (e) {
        l && (console.log(e), console.log("We're probably looking at an item."));
      }

      _i2.dataset.tooltipHref = _i2.href;

      try {
        _i2.appendChild(document.createTextNode(o.languages[t][r[e.language]]));
      } catch (e) {
        _i2.appendChild(document.createTextNode(t)), console.log("Bloodmallet charts: Translation for " + t + " wasn't found. Please help improving the reasource at bloodmallet.com.");
      }

      return _i2.outerHTML;
    }
  }

  function g(e) {
    return e.toString().toLowerCase().replace(/\s+/g, "-").replace(/[^\w\-]+/g, "").replace(/\-\-+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
  }

  function _(s) {
    if (l && console.log("update_chart_style"), "highcharts" == s.chart_engine || "highcharts_old" == s.chart_engine) {
      var _l2 = s.background_color,
          _a = s.axis_color,
          _n = s.font_color,
          _d = {
        chart: {
          type: "bar",
          backgroundColor: t,
          style: {
            fontFamily: '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"'
          }
        },
        colors: e,
        credits: {
          href: "https://bloodmallet.com/",
          text: "bloodmallet.com",
          style: {
            fontSize: i
          }
        },
        legend: {
          align: "right",
          backgroundColor: t,
          borderColor: r,
          borderWidth: 1,
          floating: !1,
          itemMarginBottom: 3,
          itemMarginTop: 0,
          layout: "vertical",
          reversed: !0,
          shadow: !1,
          verticalAlign: "middle",
          x: 0,
          y: 0,
          itemStyle: {
            color: o
          },
          itemHoverStyle: {
            color: o
          },
          title: {
            text: " ",
            style: {
              color: o
            }
          },
          symbolRadius: 0
        },
        plotOptions: {
          bar: {
            dataLabels: {
              enabled: !1
            }
          },
          series: {
            stacking: "normal",
            borderColor: t,
            events: {
              legendItemClick: function legendItemClick() {
                return !1;
              }
            },
            style: {
              textOutline: !1,
              fontSize: i
            }
          }
        },
        series: [],
        title: {
          text: "Loading data...",
          useHTML: !0,
          style: {
            color: o,
            fontSize: i
          }
        },
        subtitle: {
          text: '...from <a href="https://bloodmallet.com">bloodmallet</a>',
          useHTML: !0,
          style: {
            color: o,
            fontSize: i
          }
        },
        tooltip: {
          headerFormat: "<b>{point.x}</b>",
          shared: !0,
          backgroundColor: t,
          borderColor: r,
          style: {
            color: o,
            fontSize: i
          },
          useHTML: !0,
          positioner: function positioner(e, t, o) {
            return {
              x: o.plotX,
              y: o.plotY
            };
          }
        },
        xAxis: {
          categories: ["", "", "", "", ""],
          labels: {
            useHTML: !0,
            style: {
              color: o,
              fontSize: i
            }
          },
          gridLineWidth: 0,
          gridLineColor: r,
          lineColor: r,
          tickColor: r
        },
        yAxis: [{
          labels: {
            style: {
              color: r
            }
          },
          min: 0,
          stackLabels: {
            enabled: !0,
            formatter: function formatter() {
              return Intl.NumberFormat().format(this.total);
            },
            style: {
              color: o,
              textOutline: !1,
              fontSize: i,
              fontWeight: "normal"
            }
          },
          title: {
            text: "Δ Damage per second",
            style: {
              color: r
            }
          },
          gridLineWidth: 1,
          gridLineColor: r
        }, {
          linkedTo: 0,
          opposite: !0,
          labels: {
            style: {
              color: r
            }
          },
          min: 0,
          stackLabels: {
            enabled: !0,
            formatter: function formatter() {
              return Intl.NumberFormat().format(this.total);
            },
            style: {
              color: o,
              textOutline: !1,
              fontSize: i,
              fontWeight: "normal"
            }
          },
          title: {
            text: "Δ Damage per second",
            style: {
              color: r
            }
          },
          gridLineWidth: 1,
          gridLineColor: r
        }]
      };
      return _d.chart.backgroundColor = _l2, _d.legend.backgroundColor = _l2, _d.legend.borderColor = _a, _d.legend.itemStyle.color = _n, _d.legend.itemHoverStyle.color = _n, _d.title.style.color = _n, _d.subtitle.style.color = _n, _d.tooltip.formatter = function () {
        var e = document.createElement("div");
        e.style.margin = "-4px -7px -7px -7px", e.style.padding = "3px 3px 6px 3px", e.style.backgroundColor = _l2, "highcharts_old" === s.chart_engine && (e.style.margin = "-7px");
        var t = document.createElement("div");
        e.appendChild(t), t.style.marginLeft = "9px", t.style.marginRight = "9px", t.style.marginBottom = "6px", t.style.fontWeight = "700", t.innerHTML = this.x;
        var o = 0;

        for (var r = this.points.length - 1; r >= 0; r--) {
          if (o += this.points[r].y, 0 !== this.points[r].y) {
            var _t8 = document.createElement("div");

            e.appendChild(_t8);

            var _i3 = document.createElement("span");

            _t8.appendChild(_i3), _i3.style.marginLeft = "9px", _i3.style.borderLeft = "9px solid " + this.points[r].series.color, _i3.style.paddingLeft = "4px", _i3.innerHtml = this.points[r].series.name, _t8.appendChild(document.createTextNode("  " + Intl.NumberFormat().format(o)));
          }
        }

        return e.outerHTML;
      }, _d.tooltip.backgroundColor = _l2, _d.tooltip.borderColor = _a, _d.tooltip.style.color = _n, _d.xAxis.labels.style.color = _n, _d.xAxis.gridLineColor = _a, _d.xAxis.lineColor = _a, _d.xAxis.tickColor = _a, _d.yAxis[0].labels.style.color = _a, _d.yAxis[0].stackLabels.style.color = _n, _d.yAxis[0].gridLineColor = _a, _d.yAxis[0].lineColor = _a, _d.yAxis[0].tickColor = _a, _d.yAxis[0].title.style.color = _a, _d.yAxis[1].labels.style.color = _a, _d.yAxis[1].stackLabels.style.color = _n, _d.yAxis[1].gridLineColor = _a, _d.yAxis[1].lineColor = _a, _d.yAxis[1].tickColor = _a, _d.yAxis[1].title.style.color = _a, _d.credits.style.color = _n, _d;
    }
  }

  this.init_charts = new function () {
    l && console.log("init_charts");
    var e = document.querySelectorAll("div.bloodmallet_chart, [data-bloodmallet='chart']");

    for (var _s2 = 0; _s2 < e.length; _s2++) {
      var _a2 = e[_s2];

      if (_a2) {
        var i = {
          wow_class: void 0,
          wow_spec: void 0,
          data_type: "trinkets",
          azerite_tier: "all",
          fight_style: "patchwerk",
          corruption_representation: "dps",
          filters: {},
          axis_color: r,
          background_color: t,
          font_color: o,
          data_entries: 7,
          chart_engine: "highcharts",
          tooltip_engine: "wowhead",
          language: "en"
        };

        try {
          void 0 !== bloodmallet.style.axis_color && (i.axis_color = bloodmallet.style.axis_color), void 0 !== bloodmallet.style.background_color && (i.background_color = bloodmallet.style.background_color), void 0 !== bloodmallet.style.font_color && (i.font_color = bloodmallet.style.font_color), void 0 !== bloodmallet.settings.entries && (i.data_entries = bloodmallet.settings.entries), void 0 !== bloodmallet.settings.chart_engine && (i.chart_engine = bloodmallet.settings.chart_engine), void 0 !== bloodmallet.settings.tooltip_engine && (i.tooltip_engine = bloodmallet.settings.tooltip_engine), void 0 !== bloodmallet.settings.language && (i.language = bloodmallet.settings.language), void 0 !== bloodmallet.settings.corruption_representation && (i.corruption_representation = bloodmallet.settings.corruption_representation);
        } catch (e) {
          l && console.log("Applying page wide settings failed.");
        }

        _a2.getAttribute("data-entries") && (i.data_entries = _a2.getAttribute("data-entries")), _a2.getAttribute("data-fight-style") && (i.fight_style = _a2.getAttribute("data-fight-style")), _a2.getAttribute("data-type") && (i.data_type = _a2.getAttribute("data-type")), _a2.getAttribute("data-azerite-tier") && (i.azerite_tier = _a2.getAttribute("data-azerite-tier")), _a2.getAttribute("data-background-color") && (i.background_color = _a2.getAttribute("data-background-color")), _a2.getAttribute("data-font-color") && (i.font_color = _a2.getAttribute("data-font-color")), _a2.getAttribute("data-axis-color") && (i.axis_color = _a2.getAttribute("data-axis-color")), _a2.getAttribute("data-tooltip-engine") && (i.tooltip_engine = _a2.getAttribute("data-tooltip-engine")), _a2.getAttribute("data-chart-engine") && (i.chart_engine = _a2.getAttribute("data-chart-engine")), _a2.getAttribute("data-corruption-representation") && (i.corruption_representation = _a2.getAttribute("data-corruption-representation")), _a2.getAttribute("data-language") && (i.language = _a2.getAttribute("data-language")), _a2.getAttribute("data-filter-essence-types") && (i.filters.essence_types = _a2.getAttribute("data-filter-essence-types").split(";"));

        var _e14 = !0;

        _a2.getAttribute("data-wow-class") || (console.error("Required 'data-wow-class' attribute wasn't found in the following element."), console.log(_a2), _e14 = !1), i.wow_class = _a2.getAttribute("data-wow-class"), _a2.getAttribute("data-wow-spec") || (console.error("Required 'data-wow-spec' attribute wasn't found in the following element."), console.log(_a2), _e14 = !1), i.wow_spec = _a2.getAttribute("data-wow-spec");

        var _s3 = _(i),
            _c = !1;

        if ("highcharts" == i.chart_engine) try {
          _c = Highcharts.chart(_a2, _s3);
        } catch (e) {
          return console.error("When trying to create a highcharts chart the following error occured. Did you include the necessary Highcharts scripts?"), void console.log(e);
        } else if ("highcharts_old" == i.chart_engine) try {
          var _e15 = _s3;
          _e15.chart.renderTo = _a2, _c = new Highcharts.Chart(_e15);
        } catch (e) {
          return console.error("When trying to create a highcharts_old chart the following error occured. Did you include the necessary Highcharts scripts?"), void console.log(e);
        }

        if (_e14) {
          !0 === n(i) ? _c.setTitle({
            text: "Connection error"
          }, {
            text: "Establishing a connection to bloodmallet.com failed. Is the website blocked?"
          }, !1) : setTimeout(d, 0, i, _a2, _c, 0);
        } else _c.setTitle({
          text: "Wrong chart setup"
        }, {
          text: "Missing 'data-wow-class' or 'data-wow-spec'. See <a href=\"https://github.com/Bloodmallet/bloodmallet.github.io/wiki/How-to-import-charts-or-data\">wiki</a>"
        });
      }
    }
  }();
}

document.addEventListener("DOMContentLoaded", function () {
  bloodmallet_chart_import();
});