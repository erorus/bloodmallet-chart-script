"use strict";

function bloodmallet_chart_import() {
  var default_data_entries = 7;
  var default_tooltip_engine = "wowhead";
  var default_chart_engine = "highcharts";
  var bar_colors = ["#7cb5ec", "#d9d9df", "#90ed7d", "#f7a35c", "#8085e9", "#f15c80", "#e4d354", "#2b908f", "#f45b5b", "#91e8e1"];
  var default_background_color = "#343a40";
  var default_font_color = "#f8f9fa";
  var default_axis_color = "#828282";
  var font_size = "1.1rem";
  var default_fight_style = "patchwerk";
  var default_data_type = "trinkets";
  var default_azerite_tier = "all";
  var default_language = "en";
  var debug = !1;
  var path_to_data = "https://bloodmallet.com/json/";
  var loaded_data = {};
  this.init_charts = new function () {
    if (debug) {
      console.log("init_charts");
    }

    var chart_list = document.querySelectorAll("div.bloodmallet_chart");
    var tmp_id_list = [];

    for (var i = 0; i < chart_list.length; i++) {
      var html_element = chart_list[i];

      if (tmp_id_list.indexOf(html_element.id) > -1) {
        console.error("Multiple Elements use the same ID ('" + html_element.id + "'). Aborting bloodmallet_chart_import.js.");
        return;
      } else {
        tmp_id_list.push(html_element.id);
      }
    }

    for (var _i = 0; _i < chart_list.length; _i++) {
      var html_id = undefined;

      try {
        html_id = chart_list[_i].id;
      } catch (error) {
        console.log("No bloodmallet_chart was found.");
        return;
      }

      var _html_element = document.getElementById(chart_list[_i].id);

      if (_html_element) {
        var state = {
          wow_class: undefined,
          wow_spec: undefined,
          data_type: default_data_type,
          azerite_tier: default_azerite_tier,
          fight_style: default_fight_style,
          axis_color: default_axis_color,
          background_color: default_background_color,
          font_color: default_font_color,
          data_entries: default_data_entries,
          chart_engine: default_chart_engine,
          tooltip_engine: default_tooltip_engine,
          language: default_language
        };

        try {
          if (bloodmallet.style.axis_color !== undefined) {
            state.axis_color = bloodmallet.style.axis_color;
          }

          if (bloodmallet.style.background_color !== undefined) {
            state.background_color = bloodmallet.style.background_color;
          }

          if (bloodmallet.style.font_color !== undefined) {
            state.font_color = bloodmallet.style.font_color;
          }

          if (bloodmallet.settings.entries !== undefined) {
            state.data_entries = bloodmallet.settings.entries;
          }

          if (bloodmallet.settings.chart_engine !== undefined) {
            state.chart_engine = bloodmallet.settings.chart_engine;
          }

          if (bloodmallet.settings.tooltip_engine !== undefined) {
            state.tooltip_engine = bloodmallet.settings.tooltip_engine;
          }

          if (bloodmallet.settings.language !== undefined) {
            state.language = bloodmallet.settings.language;
          }
        } catch (error) {
          if (debug) {
            console.log("Applying page wide settings failed.");
          }
        }

        if (_html_element.getAttribute("data-entries")) {
          state.data_entries = _html_element.getAttribute("data-entries");
        }

        if (_html_element.getAttribute("data-fight-style")) {
          state.fight_style = _html_element.getAttribute("data-fight-style");
        }

        if (_html_element.getAttribute("data-type")) {
          state.data_type = _html_element.getAttribute("data-type");
        }

        if (_html_element.getAttribute("data-azerite-tier")) {
          state.azerite_tier = _html_element.getAttribute("data-azerite-tier");
        }

        if (_html_element.getAttribute("data-background-color")) {
          state.background_color = _html_element.getAttribute("data-background-color");
        }

        if (_html_element.getAttribute("data-font-color")) {
          state.font_color = _html_element.getAttribute("data-font-color");
        }

        if (_html_element.getAttribute("data-axis-color")) {
          state.axis_color = _html_element.getAttribute("data-axis-color");
        }

        if (_html_element.getAttribute("data-tooltip-engine")) {
          state.tooltip_engine = _html_element.getAttribute("data-tooltip-engine");
        }

        if (_html_element.getAttribute("data-chart-engine")) {
          state.chart_engine = _html_element.getAttribute("data-chart-engine");
        }

        if (_html_element.getAttribute("data-language")) {
          state.language = _html_element.getAttribute("data-language");
        }

        var requirements = !0;

        if (!_html_element.getAttribute("data-wow-class")) {
          console.log("Required 'data-wow-class' attribute wasn't found in " + html_id + ".");
          requirements = !1;
        }

        state.wow_class = _html_element.getAttribute("data-wow-class");

        if (!_html_element.getAttribute("data-wow-spec")) {
          console.log("Required 'data-wow-spec' attribute wasn't found in " + html_id + ".");
          requirements = !1;
        }

        state.wow_spec = _html_element.getAttribute("data-wow-spec");
        var styled_chart = update_chart_style(state);
        var new_chart = !1;

        if (state.chart_engine == "highcharts") {
          try {
            new_chart = Highcharts.chart(html_id, styled_chart);
          } catch (error) {
            console.log("When trying to create a highcharts chart the following error occured. Did you include the necessary Highcharts scripts?");
            console.log(error);
            return;
          }
        } else if (state.chart_engine == "highcharts_old") {
          try {
            tmp_styled_chart = styled_chart;
            tmp_styled_chart.chart.renderTo = html_id;
            new_chart = new Highcharts.Chart(tmp_styled_chart);
          } catch (error) {
            console.log("When trying to create a highcharts_old chart the following error occured. Did you include the necessary Highcharts scripts?");
            console.log(error);
            return;
          }
        }

        var key_value = {};
        key_value[html_id] = new_chart;

        if (requirements) {
          load_data(state);
        } else {
          requirements_error(new_chart);
        }

        setTimeout(update_chart, 2000, state, _html_element, new_chart, 0);
      }
    }
  }();

  function load_data(state) {
    if (debug) {
      console.log("load_data");
    }

    var data_type = state.data_type;
    var fight_style = state.fight_style;
    var wow_class = state.wow_class;
    var wow_spec = state.wow_spec;

    try {
      if (loaded_data[data_type][fight_style][wow_class][wow_spec]) {
        return;
      }
    } catch (error) {
      if (debug) {
        console.log("Data needs to be loaded.");
      }
    }

    var data_group = data_type;

    if (data_group.indexOf("azerite") > -1) {
      data_group = "azerite_traits";
    }

    var data_name = wow_class;
    data_name += "_" + wow_spec;

    if (data_type.indexOf("azerite_items") > -1) {
      data_name += data_type.replace("azerite_items", "");
    }

    data_name += "_" + fight_style;
    data_name += ".json";

    if (debug) {
      console.log("Fetching data from: " + path_to_data + data_group + "/" + data_name);
    }

    var request = new XMLHttpRequest();
    request.open("GET", path_to_data + data_group + "/" + data_name, !0);

    request.onload = function (e) {
      if (request.readyState === 4) {
        if (request.status === 200) {
          var json = JSON.parse(request.responseText);

          if (!loaded_data[data_type]) {
            loaded_data[data_type] = {};
          }

          if (!loaded_data[data_type][fight_style]) {
            loaded_data[data_type][fight_style] = {};
          }

          if (!loaded_data[data_type][fight_style][wow_class]) {
            loaded_data[data_type][fight_style][wow_class] = {};
          }

          loaded_data[data_type][fight_style][wow_class][wow_spec] = json;

          if (debug) {
            console.log(json);
            console.log("Load and save finished.");
          }
        } else {
          console.error(request.statusText);
        }
      }
    };

    request.onerror = function (e) {
      console.error('Fetching data from bloodmallet.com encountered an error, ', e);
    };

    request.send(null);
  }

  function update_chart(state, html_element, chart, count) {
    if (debug) {
      console.log("update_charts");
    }

    var data_type = state.data_type;
    var fight_style = state.fight_style;
    var wow_class = state.wow_class;
    var wow_spec = state.wow_spec;
    var data_entries = state.data_entries;
    var chart_engine = state.chart_engine;

    try {
      var spec_data = loaded_data[data_type][fight_style][wow_class][wow_spec];
    } catch (error) {
      console.warn("Data for ", data_type, fight_style, wow_class, wow_spec, " wasn't loaded yet. Either chart setup is wrong, connection to bloodmallet.com is slow or failed.");

      if (count < 10) {
        setTimeout(update_chart, 100, state, html_element, chart, count + 1);
      }

      return;
    }

    var data = spec_data;
    var dps_ordered_keys;
    var baseline_dps;

    if (data_type.indexOf("azerite_traits") > -1) {
      if (data_type === "azerite_traits_stacking") {
        if (state.azerite_tier === "all") {
          dps_ordered_keys = data.sorted_data_keys_2.slice(0, data_entries);
        } else if (state.azerite_tier === "1" || state.azerite_tier === "3") {
          dps_ordered_keys = data.sorted_azerite_tier_3_trait_stacking.slice(0, data_entries);
        } else if (state.azerite_tier === "2") {
          dps_ordered_keys = data.sorted_azerite_tier_2_trait_stacking.slice(0, data_entries);
        }

        baseline_dps = data.data.baseline[data.simulated_steps[0]];
      } else if (data_type === "azerite_traits_itemlevel") {
        if (state.azerite_tier === "all") {
          dps_ordered_keys = data.sorted_data_keys.slice(0, data_entries);
        } else if (state.azerite_tier === "1" || state.azerite_tier === "3") {
          dps_ordered_keys = data.sorted_azerite_tier_3_itemlevel.slice(0, data_entries);
        } else if (state.azerite_tier === "2") {
          dps_ordered_keys = data.sorted_azerite_tier_2_itemlevel.slice(0, data_entries);
        }

        baseline_dps = data.data.baseline[data.simulated_steps[data.simulated_steps.length - 1]];
      } else {
        console.log("Chart found, but unknown data-type detected.");
        return;
      }
    } else {
      dps_ordered_keys = data.sorted_data_keys.slice(0, data_entries);

      if (data_type === "races") {
        baseline_dps = 0;
      } else {
        baseline_dps = data.data.baseline[data.simulated_steps[data.simulated_steps.length - 1]];
      }
    }

    if (debug) {
      console.log(dps_ordered_keys);
      console.log("Baseline dps: " + baseline_dps);
    }

    chart.setTitle({
      text: data.title
    }, {
      text: data.subtitle
    }, !1);

    while (chart.series[0]) {
      chart.series[0].remove(!1);
    }

    category_list = [];

    for (var i = 0; i < dps_ordered_keys.length; i++) {
      var dps_key = dps_ordered_keys[i];
      category_list.push(get_category_name(state, dps_key, data));
    }

    if (debug) {
      console.log(category_list);
    }

    if (chart_engine == "highcharts") {
      chart.update({
        xAxis: {
          categories: category_list
        }
      }, !1);
    } else if (chart_engine == "highcharts_old") {
      chart.xAxis[0].setCategories(category_list, !1);
    }

    if (data_type == "azerite_traits_stacking") {
      var base_ilevel = data.simulated_steps[0].replace("1_", "");
      var simulated_steps = [];
      simulated_steps.push("3_" + base_ilevel);
      simulated_steps.push("2_" + base_ilevel);
      simulated_steps.push("1_" + base_ilevel);
    } else {
      var simulated_steps = data.simulated_steps;
    }

    if (debug) {
      console.log("simulated_steps: " + simulated_steps);
    }

    if (simulated_steps) {
      for (var itemlevel_position = 0; itemlevel_position < simulated_steps.length; itemlevel_position++) {
        var itemlevel = simulated_steps[itemlevel_position];
        var dps_array = [];

        for (var _i2 = 0; _i2 < dps_ordered_keys.length; _i2++) {
          itemlevel = simulated_steps[itemlevel_position];
          var _dps_key = dps_ordered_keys[_i2];
          var dps_key_values = data.data[_dps_key];
          baseline_dps = data.data.baseline[data.simulated_steps[data.simulated_steps.length - 1]];

          if (data_type === "azerite_traits_stacking") {
            baseline_dps = data.data.baseline[data.simulated_steps[0]];
          }

          if (data_type === "azerite_traits_stacking" && dps_key_values[itemlevel] === undefined) {
            var available_steps = data.simulated_steps;
            var max_step = undefined;

            for (var broken_id = 0; broken_id < available_steps.length; broken_id++) {
              var available_step = available_steps[broken_id];

              if (!max_step && data.data[_dps_key][available_step]) {
                max_step = available_step;
              }
            }

            max_step = max_step.replace("1_", "");
            baseline_dps = data.data.baseline["1_" + max_step];
            itemlevel = itemlevel.split("_")[0] + "_" + max_step;
          }

          if (Number(dps_key_values[itemlevel]) > 0) {
            if (itemlevel_position == simulated_steps.length - 1) {
              if (itemlevel in dps_key_values) {
                dps_array.push(dps_key_values[itemlevel] - baseline_dps);
              } else {
                dps_array.push(0);
              }
            } else {
              if (dps_key_values[simulated_steps[String(Number(itemlevel_position) + 1)]] == 0 || !(simulated_steps[String(Number(itemlevel_position) + 1)] in dps_key_values)) {
                dps_array.push(dps_key_values[itemlevel] - baseline_dps);
              } else {
                dps_array.push(dps_key_values[itemlevel] - dps_key_values[simulated_steps[String(Number(itemlevel_position) + 1)]]);
              }
            }
          } else {
            if (itemlevel in dps_key_values) {
              dps_array.push(dps_key_values[itemlevel]);
            } else {
              dps_array.push(0);
            }
          }
        }

        var itemlevel_clean = itemlevel;

        if (["azerite_items_chest", "azerite_items_head", "azerite_items_shoulders", "azerite_traits_itemlevel"].indexOf(data_type) > -1) {
          itemlevel_clean = itemlevel.split("_")[1];
        } else if (data_type === "azerite_traits_stacking") {
          itemlevel_clean = itemlevel.split("_")[0];
        }

        chart.addSeries({
          data: dps_array,
          name: itemlevel_clean,
          showInLegend: !0
        }, !1);
      }
    } else {
      var dps_array = [];

      for (var _i3 = 0; _i3 < dps_ordered_keys.length; _i3++) {
        var _dps_key2 = dps_ordered_keys[_i3];
        var _dps_key_values = data.data[_dps_key2];
        dps_array.push(_dps_key_values);
      }

      chart.addSeries({
        data: dps_array,
        name: "Race",
        showInLegend: !0
      }, !1);
    }

    if ("trinkets" == data_type || "azerite_items_chest" == data_type || "azerite_items_head" == data_type || "azerite_items_shoulders" == data_type || "azerite_traits_itemlevel" == data_type) {
      chart.legend.title.attr({
        text: "Itemlevel"
      });
    } else if (data_type === "races") {
      chart.legend.title.attr({
        text: ""
      });
    } else if (data_type === "azerite_traits_stacking") {
      chart.legend.title.attr({
        text: "Trait count"
      });
    }

    html_element.style.height = 200 + dps_ordered_keys.length * 30 + "px";

    if (chart_engine == "highcharts") {
      chart.setSize(html_element.style.width, html_element.style.height);
    }

    chart.redraw();

    if (chart_engine == "highcharts_old") {
      chart.reflow();
    }

    if (state.tooltip_engine == "wowdb") {
      setTimeout(function () {
        readd_wowdb_tooltips(html_element.id);
      }, 1);
    }
  }

  function readd_wowdb_tooltips(chart_id) {
    if (debug) {
      console.log("readd_wowdb_tooltips");
    }

    try {
      CurseTips['wowdb-tooltip'].watchElements(document.getElementById(chart_id).getElementsByTagName('a'));
    } catch (error) {
      console.log("Setting wowdb (CurseTips) tooltips failed. Error: ", error);
    }
  }

  function get_category_name(state, key, data) {
    if (debug) {
      console.log("get_category_name");
      console.log(key);
      console.log(data);
    }

    var language_table = {
      "cn": "cn_CN",
      "en": "en_US",
      "de": "de_DE",
      "es": "es_ES",
      "fr": "fr_FR",
      "it": "it_IT",
      "ko": "ko_KR",
      "pt": "pt_BR",
      "ru": "ru_RU"
    };

    if (state.tooltip_engine != "wowhead" && state.tooltip_engine != "wowdb") {
      return data.languages[key][language_table[state.language]];
    }

    if (state.data_type === "races") {
      return data.languages[key][language_table[state.language]];
    }

    if (state.tooltip_engine == "wowhead") {
      var link = "<a href=\"https://";

      if (state.language === "en") {
        link += "www";
      } else {
        link += state.language;
      }

      link += ".wowhead.com/";

      try {
        var item_id = data.item_ids[key];
        link += "item=" + item_id;
        link += "/" + slugify(key);
      } catch (error) {
        if (debug) {
          console.log(error);
          console.log("We're probably looking at a spell.");
        }
      }

      if (link.indexOf("item") > -1) {
        if (data.hasOwnProperty("class_id") && data.hasOwnProperty("used_azerite_traits_per_item")) {
          link += "?azerite-powers=";
          link += data.class_id;

          for (var i = 0; i < data.used_azerite_traits_per_item[key].length; i++) {
            var trait = data.used_azerite_traits_per_item[key][i];
            link += ":" + trait.id;
          }
        }

        var ilvl = data.simulated_steps[data.simulated_steps.length - 1];

        if (typeof ilvl === 'string') {
          if (ilvl.indexOf("_") > -1) {
            ilvl = ilvl.split("_")[1];
          }
        }

        link += "&ilvl=" + ilvl;
      }

      try {
        var spell_id = data.spell_ids[key];
        link += "spell=" + spell_id;
        link += "/" + slugify(key);
      } catch (error) {
        if (debug) {
          console.log(error);
          console.log("We're probably looking at an item.");
        }
      }

      link += "\">";

      try {
        link += data.languages[key][language_table[state.language]];
      } catch (error) {
        link += key;
        console.log("Bloodmallet charts: Translation for " + key + " wasn't found. Please help improving the reasource at bloodmallet.com.");
      }

      link += "</a>";
      return link;
    }

    if (state.tooltip_engine == "wowdb") {
      var element_string = "<a href=\"";
      var _link = "http://www.wowdb.com/";

      try {
        var _item_id = data.item_ids[key];
        _link += "items/" + _item_id;
      } catch (error) {
        if (debug) {
          console.log(error);
          console.log("We're probably looking at a spell.");
        }
      }

      if (_link.indexOf("items") > -1) {
        var _ilvl = data.simulated_steps[data.simulated_steps.length - 1];

        if (typeof _ilvl === 'string') {
          if (_ilvl.indexOf("_") > -1) {
            _ilvl = _ilvl.split("_")[1];
          }
        }

        _link += "?itemLevel=" + _ilvl;

        if (data.hasOwnProperty("class_id") && data.hasOwnProperty("used_azerite_traits_per_item")) {
          _link += "&azerite=";
          _link += data.class_id + ":0";

          for (var _i4 = 0; _i4 < data.used_azerite_traits_per_item[key].length; _i4++) {
            var _trait = data.used_azerite_traits_per_item[key][_i4];
            _link += ":" + _trait.id;
          }
        }
      }

      try {
        var _spell_id = data.spell_ids[key];
        _link += "spells/" + _spell_id;
      } catch (error) {
        if (debug) {
          console.log(error);
          console.log("We're probably looking at an item.");
        }
      }

      element_string += _link;
      element_string += "\" data-tooltip-href=\"";
      element_string += _link + "\">";

      try {
        element_string += data.languages[key][language_table[state.language]];
      } catch (error) {
        element_string += key;
        console.log("Bloodmallet charts: Translation for " + key + " wasn't found. Please help improving the reasource at bloodmallet.com.");
      }

      element_string += "</a>";
      return element_string;
    }
  }

  function requirements_error(chart) {
    chart.setTitle({
      text: "Wrong chart setup"
    }, {
      text: "Missing 'data-wow-class' or 'data-wow-spec'. See <a href=\"https://github.com/Bloodmallet/bloodmallet.github.io/wiki/How-to-import-charts-or-data\">wiki</a>"
    });
  }

  function slugify(text) {
    return text.toString().toLowerCase().replace(/\s+/g, '-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
  }

  function update_chart_style(state) {
    if (debug) {
      console.log("update_chart_style");
    }

    if (state.chart_engine == "highcharts" || state.chart_engine == "highcharts_old") {
      var background_color = state.background_color;
      var axis_color = state.axis_color;
      var font_color = state.font_color;
      var styled_chart = {
        chart: {
          type: "bar",
          backgroundColor: default_background_color,
          style: {
            fontFamily: "-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\""
          }
        },
        colors: bar_colors,
        credits: {
          href: "https://bloodmallet.com/",
          text: "bloodmallet.com",
          style: {
            fontSize: font_size
          }
        },
        legend: {
          align: "right",
          backgroundColor: default_background_color,
          borderColor: default_axis_color,
          borderWidth: 1,
          floating: !1,
          itemMarginBottom: 3,
          itemMarginTop: 0,
          layout: 'vertical',
          reversed: !0,
          shadow: !1,
          verticalAlign: "middle",
          x: 0,
          y: 0,
          itemStyle: {
            color: default_font_color
          },
          itemHoverStyle: {
            color: default_font_color
          },
          title: {
            text: " ",
            style: {
              color: default_font_color
            }
          },
          symbolRadius: 0
        },
        plotOptions: {
          bar: {
            dataLabels: {
              enabled: !1
            }
          },
          series: {
            stacking: "normal",
            borderColor: default_background_color,
            events: {
              legendItemClick: function legendItemClick() {
                return !1;
              }
            },
            style: {
              textOutline: !1,
              fontSize: font_size
            }
          }
        },
        series: [{
          color: default_font_color,
          data: [1, 1, 3, 1, 3],
          name: "b main",
          showInLegend: !1
        }, {
          color: default_background_color,
          data: [0, 0, 0, 1, 0],
          name: "b's emptiness",
          showInLegend: !1
        }, {
          color: default_font_color,
          data: [0, 0, 0, 1, 0],
          name: "b's finishing touch",
          showInLegend: !1
        }],
        title: {
          text: "Loading data...",
          useHTML: !0,
          style: {
            color: default_font_color,
            fontSize: font_size
          }
        },
        subtitle: {
          text: "...from <a href=\"https://bloodmallet.com\">bloodmallet</a>",
          useHTML: !0,
          style: {
            color: default_font_color,
            fontSize: font_size
          }
        },
        tooltip: {
          formatter: function formatter() {
            var s = '<div style="margin: -4px -7px -7px -7px; padding: 3px 3px 6px 3px; background-color:';
            s += default_background_color;
            s += '"><div style=\"margin-left: 9px; margin-right: 9px; margin-bottom: 6px; font-weight: 700;\">';
            s += this.x;
            s += '</div>';
            var cumulative_amount = 0;

            for (var i = this.points.length - 1; i >= 0; i--) {
              cumulative_amount += this.points[i].y;

              if (this.points[i].y !== 0) {
                s += '<div><span style=\"margin-left: 9px; border-left: 9px solid ' + this.points[i].series.color + ';' + ' padding-left: 4px;\">' + this.points[i].series.name + '</span>:&nbsp;&nbsp;' + Intl.NumberFormat().format(cumulative_amount) + "</div>";
              }
            }

            s += '</div>';
            return s;
          },
          headerFormat: "<b>{point.x}</b>",
          shared: !0,
          backgroundColor: default_background_color,
          borderColor: default_axis_color,
          style: {
            color: default_font_color,
            fontSize: font_size
          },
          useHTML: !0,
          positioner: function positioner(boxWidth, boxHeight, point) {
            return {
              x: point.plotX,
              y: point.plotY
            };
          }
        },
        xAxis: {
          categories: ["", "", "", "", ""],
          labels: {
            useHTML: !0,
            style: {
              color: default_font_color,
              fontSize: font_size
            }
          },
          gridLineWidth: 0,
          gridLineColor: default_axis_color,
          lineColor: default_axis_color,
          tickColor: default_axis_color
        },
        yAxis: [{
          labels: {
            style: {
              color: default_axis_color
            }
          },
          min: 0,
          stackLabels: {
            enabled: !0,
            formatter: function formatter() {
              return Intl.NumberFormat().format(this.total);
            },
            style: {
              color: default_font_color,
              textOutline: !1,
              fontSize: font_size,
              fontWeight: "normal"
            }
          },
          title: {
            text: "\u0394 Damage per second",
            style: {
              color: default_axis_color
            }
          },
          gridLineWidth: 1,
          gridLineColor: default_axis_color
        }, {
          linkedTo: 0,
          opposite: !0,
          labels: {
            style: {
              color: default_axis_color
            }
          },
          min: 0,
          stackLabels: {
            enabled: !0,
            formatter: function formatter() {
              return Intl.NumberFormat().format(this.total);
            },
            style: {
              color: default_font_color,
              textOutline: !1,
              fontSize: font_size,
              fontWeight: "normal"
            }
          },
          title: {
            text: "\u0394 Damage per second",
            style: {
              color: default_axis_color
            }
          },
          gridLineWidth: 1,
          gridLineColor: default_axis_color
        }]
      };
      styled_chart.chart.backgroundColor = background_color;
      styled_chart.legend.backgroundColor = background_color;
      styled_chart.legend.borderColor = axis_color;
      styled_chart.legend.itemStyle.color = font_color;
      styled_chart.legend.itemHoverStyle.color = font_color;
      styled_chart.title.style.color = font_color;
      styled_chart.subtitle.style.color = font_color;

      styled_chart.tooltip.formatter = function () {
        var s = '<div style="margin: -4px -7px -7px -7px; padding: 3px 3px 6px 3px; background-color:';

        if (state.chart_engine === "highcharts_old") {
          s = '<div style="margin: -7px; padding: 3px 3px 6px 3px; background-color:';
        }

        s += background_color;
        s += '"><div style=\"margin-left: 9px; margin-right: 9px; margin-bottom: 6px; font-weight: 700;\">';
        s += this.x;
        s += '</div>';
        var cumulative_amount = 0;

        for (var i = this.points.length - 1; i >= 0; i--) {
          cumulative_amount += this.points[i].y;

          if (this.points[i].y !== 0) {
            s += '<div><span style=\"margin-left: 9px; border-left: 9px solid ' + this.points[i].series.color + ';' + ' padding-left: 4px;\">' + this.points[i].series.name + '</span>:&nbsp;&nbsp;' + Intl.NumberFormat().format(cumulative_amount) + "</div>";
          }
        }

        s += '</div>';
        return s;
      };

      styled_chart.tooltip.backgroundColor = background_color;
      styled_chart.tooltip.borderColor = axis_color;
      styled_chart.tooltip.style.color = font_color;
      styled_chart.xAxis.labels.style.color = font_color;
      styled_chart.xAxis.gridLineColor = axis_color;
      styled_chart.xAxis.lineColor = axis_color;
      styled_chart.xAxis.tickColor = axis_color;
      styled_chart.yAxis[0].labels.style.color = axis_color;
      styled_chart.yAxis[0].stackLabels.style.color = font_color;
      styled_chart.yAxis[0].gridLineColor = axis_color;
      styled_chart.yAxis[0].lineColor = axis_color;
      styled_chart.yAxis[0].tickColor = axis_color;
      styled_chart.yAxis[0].title.style.color = axis_color;
      styled_chart.yAxis[1].labels.style.color = axis_color;
      styled_chart.yAxis[1].stackLabels.style.color = font_color;
      styled_chart.yAxis[1].gridLineColor = axis_color;
      styled_chart.yAxis[1].lineColor = axis_color;
      styled_chart.yAxis[1].tickColor = axis_color;
      styled_chart.yAxis[1].title.style.color = axis_color;
      styled_chart.credits.style.color = font_color;
      return styled_chart;
    }
  }
}

document.addEventListener("DOMContentLoaded", function () {
  bloodmallet_chart_import();
});